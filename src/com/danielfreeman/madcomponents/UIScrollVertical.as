/** * <p>Original Author: Daniel Freeman</p> * * <p>Permission is hereby granted, free of charge, to any person obtaining a copy * of this software and associated documentation files (the "Software"), to deal * in the Software without restriction, including without limitation the rights * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell * copies of the Software, and to permit persons to whom the Software is * furnished to do so, subject to the following conditions:</p> * * <p>The above copyright notice and this permission notice shall be included in * all copies or substantial portions of the Software.</p> * * <p>THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN * THE SOFTWARE.</p> * * <p>Licensed under The MIT License</p> * <p>Redistributions of files must retain the above copyright notice.</p> */package com.danielfreeman.madcomponents {	import flash.display.DisplayObject;	import flash.display.Shape;	import flash.display.Sprite;	import flash.events.Event;	import flash.events.MouseEvent;	import flash.events.TimerEvent;	import flash.geom.Point;	import flash.utils.Timer;	import flash.geom.Rectangle;	import flash.display.InteractiveObject;/** * Scrolling has started */	[Event( name="scrollStarted", type="flash.events.Event" )]	/** * Scrolling has ceased */	[Event( name="scrollStopped", type="flash.events.Event" )]	  /** *  MadComponents vertically scrolling container * <pre> * &lt;scrollVertical *    id = "IDENTIFIER" *    colour = "#rrggbb" *    background = "#rrggbb, #rrggbb, …" *    gapV = "NUMBER" *    gapH = "NUMBER" *    alignH = "left|right|centre|fill" *    alignV = "top|bottom|centre|fill" *    visible = "true|false" *    border = "true|false" *    autoLayout = "true|false" *    scrollV = "scroll|no scroll|auto" *    alwaysScrollBar = "true|false" * /&gt; * </pre> */		public class UIScrollVertical extends MadMasking implements IContainerUI {		public static const STARTED:String = "scrollStarted";		public static const STOPPED:String = "scrollStopped";	//	protected static const DEBUG:Boolean = true;		protected static const DELTA_THRESHOLD:Number = 2.0;		protected static const THRESHOLD:Number = 8.0; // was 16		protected static const ABORT_THRESHOLD:Number = 8.0;//was 64		protected static const PADDING:Number = 10.0;		protected static const SCROLLBAR_POSITION:Number = 2.0;		protected static const SCROLLBAR_WIDTH:Number = 5.0;		protected static const MAXIMUM_DY:Number = 2048.0;		protected static const FINISHED:Number = -99999;		protected static const SMOOTH:Number = 0.5;	//	public static var FAST_DELTA_THRESHOLD:Number = 99999.9;		protected static const MARGIN:Number = 6.0;	//	public static var SWIPE_FACTOR:Number = 1.2;	//	public static var FAST_SWIPE_FACTOR:Number = 2.4;	//	public static var DECAY:Number = 0.95;		public static var DELTA:int = 10;		public static var DELTA_TOUCH:int = 10;		public static var BOUNCE:Number = 0.5;		public static var CLICK_DURATION:int = 167;				public static var SLOW_DECAY:Array = [0.85, 0.90];		public static var FAST_DECAY:Array = [0.99, 0.99];		public static var SLOW_DECAY_DELTA:Array = [0.0, 0.40];		public static var FAST_DECAY_DELTA:Array = [150.0, 100];				public static var SPEED:int = 1;		public static var FLICK_THRESHOLD:Number = 2;				protected static const MAXIMUM_TICKS:int = 3;		protected static const DAMPEN:Number = 0.3;		protected static const NO_SWIPE_THRESHOLD:int = 1;		public static const TOUCH_DELAY:int = 8;		protected var _maximumSlide:Number;		protected var _delta:Number = 0.0;		protected var _startMouse:Point = new Point();		protected var _lastMouse:Point = new Point();		protected var _startSlider:Point = new Point();		protected var _endSlider:Number = -1;		protected var _slider:Sprite;		protected var _sliderPosition:Number = 0;				protected var _touchTimer:Timer = new Timer(DELTA_TOUCH);		protected var _moveTimer:Timer = new Timer(DELTA);		protected var _dragTimer:Timer = new Timer(DELTA);		protected var _clickTimer:Timer = new Timer(CLICK_DURATION, 1);		protected var _distance:Number = 0;		protected var _pressButton:DisplayObject;		protected var _searchHitChild:DisplayObject;		protected var _scrollBarLayer:Shape;		protected var _width:Number;		protected var _height:Number;		protected var _colour:uint;		protected var _scrollBarColour:uint;		protected var _noScroll:Boolean;		protected var _deltaThreshold:Number = 1.0;		protected var _listClickable:Boolean = true;		protected var _autoLayout:Boolean = false;	//	protected var _decay:Number = SLOW_DECAY;		protected var _offset:Number = 0;		protected var _scrollBarVisible:Boolean = false;		protected var _scrollerWidth:Number = -1;		protected var _scrollerHeight:Number = -1;		protected var _border:String;		protected var _scale:Number = 1.0;		protected var _dampen:Number = DAMPEN;		protected var _classic:Boolean = false;			//	protected var _initial:int = 0;			//	protected var _oldDeltaY:Number = 0;	//	protected var _swipeDurationY:int;	//	protected var _swipeTotalY:Number;		protected var _autoScrollEnabled:Boolean;		protected var _alwaysScrollBar:Boolean = false;	//	protected var _swipeFactor:Number = SWIPE_FACTOR;		protected var _noSwipeCount:int = 0;	//	protected var _isFastSwipe:Boolean = false;		protected var _profile:int = SPEED;					public function UIScrollVertical(screen:Sprite, xml:XML, attributes:Attributes) {			if (screen) {				screen.addChildAt(this,0);			}			if (xml.@speed == "slow") {				_profile = 0;			}			else if (xml.@speed == "fast") {				_profile = 1;			}			_classic = xml.@classic == "true";			_autoScrollEnabled = xml.@scrollY == "auto";			_alwaysScrollBar = xml.@alwaysScrollBar == "true";			super(null, xml, attributes);						_border = xml.@border.length()>0 ? xml.@border[0] : "";			if (xml.@dampen.length() > 0) {				_dampen = parseFloat(xml.@dampen);			}			_colour = attributes.colour;			_noScroll = xml.@scrollV == "false";			_scrollBarColour = attributes.scrollBarColour;			createSlider(xml, attributes);			if (xml.@autoLayout.length()>0 && xml.@autoLayout[0]!="false") {				_slider.addEventListener(UIImageLoader.LOADED, doLayoutHandler);				_autoLayout = true;			}			addChild(_scrollBarLayer = new Shape());			_scrollBarLayer.alpha = 0.8;			_clickTimer.addEventListener(TimerEvent.TIMER, clickUp);			addEventListener(MouseEvent.MOUSE_DOWN, mouseDown);			addListeners();			drawComponent();			androidMouseDisable(_slider);			startMasking();			if (_alwaysScrollBar) {				showScrollBar();			}		}					//	public function setScrollFactors(swipeFactor:Number, decay:Number = -1):void {	//		_swipeFactor = swipeFactor;	//		_decay = decay;	//	}						public function set dampen(value:Number):void {			_dampen = value;		}						protected function addListeners():void {			_touchTimer.addEventListener(TimerEvent.TIMER, mouseMove);			_dragTimer.addEventListener(TimerEvent.TIMER, mouseDrag);			_moveTimer.addEventListener(TimerEvent.TIMER, movement);		//	_clickTimer.addEventListener(TimerEvent.TIMER, clickUp);		}						protected function removeListeners():void {			removeEventListener(MouseEvent.MOUSE_DOWN, mouseDown);			stage.removeEventListener(MouseEvent.MOUSE_UP, mouseUp);			_touchTimer.removeEventListener(TimerEvent.TIMER, mouseMove);			_dragTimer.removeEventListener(TimerEvent.TIMER, mouseDrag);			_moveTimer.removeEventListener(TimerEvent.TIMER, movement);		//	_clickTimer.removeEventListener(TimerEvent.TIMER, clickUp);		}						protected function deltaToDecay(delta:Number):Number {			var factor:Number;			if (Math.abs(delta) < SLOW_DECAY_DELTA[_profile]) {				factor = 0.0;			}			else if (Math.abs(delta) > FAST_DECAY_DELTA[_profile]) {				factor = 1.0;			}			else {				factor = (Math.abs(delta) - SLOW_DECAY_DELTA[_profile]) / (FAST_DECAY_DELTA[_profile] - SLOW_DECAY_DELTA[_profile]);			}			return factor * (FAST_DECAY[_profile] - SLOW_DECAY[_profile]) + SLOW_DECAY[_profile];		}		/** *  If false, scrolling is locked. */		public function set scrollEnabled(value:Boolean):void {			_noScroll = !value;			if (_noScroll) {				stopMovement();			}		}		/** *  Is this container scrollable, or locked? */		public function get scrollEnabled():Boolean {			return !_noScroll;		}		/** *  Draw background */			public function drawComponent():void {			if (!isNaN(_width) && !isNaN(_height)) {				UI.drawBackgroundColour(_attributes.backgroundColours, _width, _height, this);			}		}		/** *  Returns scrolling form within array */			public function get pages():Array {			return [_slider];		}						public function get xml():XML {			return _xml;		}		/** *  Rearrange the layout to new screen dimensions */			override public function layout(attributes:Attributes):void {			super.layout(attributes);			if (_slider is IComponentUI) {				IComponentUI(_slider).layout(sliderAttributes(attributes));			}			drawComponent();			adjustMaximumSlide();					//	if (scrollRect)		//		scrollRect = new Rectangle(0,0,attributes.width,attributes.height);					refreshMasking();			if (_alwaysScrollBar) {				showScrollBar();			}		}						public function rowRectangle(y:Number):Rectangle {			for (var l:int=0;l<_slider.numChildren - 1;l++) {				var row:DisplayObject = _slider.getChildAt(l+1);				if (row.y + row.height + _attributes.paddingV > y) {					return new Rectangle(row.x - _attributes.paddingH / 2, row.y - _attributes.paddingV / 2, row.width + _attributes.paddingH, row.height + _attributes.paddingV);				}			}			return null;		}						protected function adjustVerticalSlide():void {			var sliderHeight:Number = _scrollerHeight>0 ? _scrollerHeight*_scale : _slider.getBounds(_slider).bottom;			_maximumSlide = sliderHeight - _height + PADDING * (_border=="false" ? 0 : 1);			if (_maximumSlide < 0) {				_maximumSlide = 0;			}			if (_autoScrollEnabled) {				_noScroll = _maximumSlide == 0;			}			if (sliderY < -_maximumSlide) {				sliderY = -_maximumSlide;			}		}		/** *  Update maximum slide */			protected function adjustMaximumSlide():void {			adjustVerticalSlide();		}						protected function doLayoutHandler(event:Event):void {			doLayout();			event.stopPropagation();		}						public function get maximumSlide():Number {			return _maximumSlide;		}		/** *  Refresh */			public function doLayout():void {			if (_slider is UIForm) {				if (_autoLayout) {					UIForm(_slider).doLayout();				}				adjustMaximumSlide();			}		}						public function set xml(value:XML):void {			UIForm(_slider).xml = value;			adjustMaximumSlide();		}		/** *  Create sliding part of container */			protected function createSlider(xml:XML, attributes:Attributes):void {			_slider = new UI.FormClass(this, xml, sliderAttributes(attributes));			_slider.name = "-";			adjustMaximumSlide();		}						protected function sliderAttributes(attributes:Attributes):Attributes {			_width = attributes.width;			_height = attributes.height;			var newAttributes:Attributes = attributes.copy();			var padding:Number = (_border=="true" || (_border!="false" && _xml.localName().toString().indexOf("scroll")>=0)) ? PADDING : 0;			if (_xml.@width.length()>0) {				newAttributes.width = _scrollerWidth = parseFloat(_xml.@width[0]);			}			if (_xml.@height.length()>0) {				newAttributes.height = _scrollerHeight = parseFloat(_xml.@height[0]);			}			newAttributes.width -= 2*padding;			newAttributes.x=padding;			newAttributes.y=padding;			return newAttributes;		}		/** *  Disable touch events to scrolling components */			protected function androidMouseDisable(item:Sprite):void {			for (var i:int = 0; i<item.numChildren;i++) {				var child:DisplayObject = DisplayObject(item.getChildAt(i));				if (child is MadSprite) {					MadSprite(child).mouseEnabled = false;				}				else if (child is IContainerUI && Sprite(child).mouseChildren) {					for each (var page:Sprite in IContainerUI(child).pages) {						androidMouseDisable(page);					}					if (child is UIForm) {						UIForm(child).insideScroller();					}				}				else if (!(child is UIInput) && !(child is UISearch)  && !(child is UIBlueText) && child.hasOwnProperty("mouseEnabled")) {					Object(child).mouseEnabled = false;				}			} 		}						protected function mouseDown(event:MouseEvent):void {			if (_pressButton || mouseX > _attributes.width) {				return;			}					//	hideScrollBar();			removeEventListener(MouseEvent.MOUSE_DOWN, mouseDown);			stage.addEventListener(MouseEvent.MOUSE_UP, mouseUp);			_lastMouse.x = _startMouse.x = mouseX;			_lastMouse.y = _startMouse.y = mouseY;			_startSlider.x = _slider.x;			_startSlider.y = sliderY;			_listClickable = !_moveTimer.running;			_moveTimer.stop();			_touchTimer.reset();			_touchTimer.start();			_distance = 0;	//		_oldDeltaY = 0;			if (!_classic && Math.abs(_delta) <= DELTA_THRESHOLD) {				pressButton(false);			}			_delta = 0;	//		_swipeDurationY = 0;	//		_swipeTotalY = 0;		}						override public function touchCancel():void {			if (_pressButton && _pressButton.name == "$" && _pressButton.parent && _pressButton.parent is UIForm) {				UIForm(_pressButton.parent).touchCancel();			}			else if (_pressButton && _pressButton is MadSprite) {				MadSprite(_pressButton).touchCancel();			}		}						public function stopScrolling():void {			handleFlick();			stage.removeEventListener(MouseEvent.MOUSE_UP, mouseUp);			_dragTimer.stop();			_touchTimer.stop();//			_moveTimer.stop();			removeEventListener(MouseEvent.MOUSE_DOWN, mouseDown);			addEventListener(MouseEvent.MOUSE_DOWN, mouseDown);		}		/** *  A rapid flick to scroll occurs too quickly to be handled by the usual scrolling algorithm *  So deal with them as a special case. */			protected function handleFlick():void {			if (_touchTimer.currentCount <= FLICK_THRESHOLD) {				_delta = (mouseY - _startMouse.y) / ((_touchTimer.currentCount == 0) ? 1 : _touchTimer.currentCount);			}		}						protected function mouseUp(event:MouseEvent):void {			stopScrolling();			if (!_noScroll) {				startMovement();			}			if (_pressButton) {				_pressButton.dispatchEvent(new MouseEvent(MouseEvent.MOUSE_UP));				stage.dispatchEvent(new MouseEvent(MouseEvent.MOUSE_UP));				_pressButton = null;			}		}				protected function mouseMove(event:TimerEvent):void {			if (!_noScroll) {				var delta:Number = -sliderY;				sliderY += (outsideSlideRange ? _dampen : 1.0) * (mouseY - _lastMouse.y);				delta += sliderY;								if (Math.abs(delta) > DELTA_THRESHOLD) {					if (delta * _delta > 0) {						_delta = SMOOTH * _delta + (1 - SMOOTH) * delta;					}					else {						_delta = delta;					}					_noSwipeCount = 0;				}				else if (++_noSwipeCount > NO_SWIPE_THRESHOLD) {					_delta = 0;				}				_distance += Math.abs(mouseY - _lastMouse.y); // + Math.abs(mouseX - _startMouse.x);				_lastMouse.x = mouseX;				_lastMouse.y = mouseY;			}			if (!_noScroll && _distance > ABORT_THRESHOLD) {				showScrollBar();			}			else if (_touchTimer.currentCount == MAXIMUM_TICKS && _classic && _distance < THRESHOLD) {				pressButton();			}			else if (_touchTimer.currentCount == TOUCH_DELAY && !_classic && Math.abs(_delta) <= DELTA_THRESHOLD) {				pressButton();			}		}						protected function mouseDrag(event:TimerEvent):void {			if (_pressButton) {				stage.dispatchEvent(new MouseEvent(MouseEvent.MOUSE_MOVE));			}		}		/** *  Start scrolling movement */			protected function startMovement():void {			_endSlider = FINISHED-1;			startMovement0();			_moveTimer.start();		}						protected function startMovement0():Boolean {			if (sliderY > _offset) {				_endSlider = -_offset;				return true;			}			else if (sliderY < -_maximumSlide ) {				_endSlider = _maximumSlide;				return true;			}			return false;		}		/** *  Animate scrolling movement */		protected function movement(event:TimerEvent):void {			if (_endSlider < FINISHED) {			//	_delta *= _decay;				_delta *= deltaToDecay(_delta);				sliderY = sliderY + _delta;				if (_distance > THRESHOLD) {					showScrollBar();				}				if (Math.abs(_delta) < _deltaThreshold || sliderY > 0 || sliderY < -_maximumSlide) {					if (!startMovement0()) {						stopMovement();					}				}			}			else {				_delta = (-_endSlider - sliderY) * BOUNCE;				sliderY = sliderY + _delta;				showScrollBar();				if (Math.abs(_delta) < _deltaThreshold) {					sliderY = -_endSlider;					stopMovement();				}			}		}		/** *  Stop scrolling movement */		protected function stopMovement():void {			_moveTimer.stop();			_delta = 0;			hideScrollBar();		}		/** *  Show scroll bar */		public function showScrollBar():void {			if (!_scrollBarVisible) {				touchCancel();				_scrollBarVisible = true;				dispatchEvent(new Event(STARTED));			}			drawScrollBar();		}						protected function getSliderHeight():Number {			return _scrollerHeight>0 ? _scrollerHeight*_scale : _slider.getBounds(_slider).bottom;		}		/** *  Draw scroll bar */		protected function drawScrollBar():void {			if (_noScroll) {				return;			}			var sliderHeight:Number = getSliderHeight();			_scrollBarLayer.graphics.clear();			var barHeight:Number = (_height / sliderHeight) * _height;			var barPosition:Number = (- sliderY / sliderHeight) * _height + 2*SCROLLBAR_POSITION;			if (barPosition < SCROLLBAR_POSITION) {				barHeight += barPosition;				barPosition = SCROLLBAR_POSITION;				}			if (barPosition + barHeight > _height - 2 * SCROLLBAR_POSITION) {				barHeight -= barPosition + barHeight - _height + 2 * SCROLLBAR_POSITION;			}			if (barHeight > 0 && barPosition >= 0) {				_scrollBarLayer.graphics.beginFill(_scrollBarColour);				_scrollBarLayer.graphics.drawRoundRect(_width - SCROLLBAR_WIDTH - SCROLLBAR_POSITION, barPosition, SCROLLBAR_WIDTH, barHeight, SCROLLBAR_WIDTH);			}		}/** *  Hide scroll bar */		public function hideScrollBar():void {			dispatchEvent(new Event(STOPPED));			if (_scrollBarVisible && (!_alwaysScrollBar || _noScroll)) {				_scrollBarLayer.graphics.clear();				_scrollBarVisible = false;			}		}/** *  Determine what has been clicked */		protected function doSearchHit():void {			if (!_pressButton) {				_pressButton = searchHit(_slider);				if (_pressButton is UIInput) {					_pressButton = null;				}				else if (_pressButton && _pressButton is InteractiveObject) {					_searchHitChild = UIScrollVertical.searchHitChild(_pressButton);					(_searchHitChild ? _searchHitChild : _pressButton).dispatchEvent(new MouseEvent(MouseEvent.MOUSE_DOWN));					_dragTimer.start();				}			}		}				protected function pressButton(show:Boolean = true):DisplayObject {			doSearchHit();			return _pressButton;		}		/** *  Touch up handler */		protected function clickUp(event:TimerEvent):void {			if (_pressButton && _distance < THRESHOLD) {				_dragTimer.stop();				_pressButton.dispatchEvent(new MouseEvent(MouseEvent.MOUSE_UP));				_pressButton = null;				stopMovement();			}		}		/** *  Return DisplayObject of what has been clicked */		public static function searchHit(container:Sprite = null):DisplayObject {		var found:DisplayObject = null;			for (var i:int = 0; i < container.numChildren && !found; i++) {				var item:* = container.getChildAt(container.numChildren - i -1);			//	if (item is UIForm && UIForm(item).clickable && UIForm(item).visible) {				if (item is IContainerUI && MadSprite(item).clickable && MadSprite(item).visible) {					found = searchHit(item);				}				else {					if (item && inBounds(item, container.mouseX, container.mouseY) && !(item is UILabel) && !((item is MadSprite) && !MadSprite(item).clickable)) {						found = item;					}				}			}			return found;		}				/** *  Return DisplayObject of what has been clicked */		public static function searchHitChild(item:DisplayObject = null):DisplayObject {			var found:DisplayObject = null;			if (item is Sprite && Sprite(item).mouseEnabled) {				for (var i:int = 0; i < Sprite(item).numChildren && !found; i++) {					found = searchHitChild(Sprite(item).getChildAt(Sprite(item).numChildren - i -1));				}			}			var bounds:Rectangle = item.getBounds(item);			if (!found && inBoundsChild(item, item.mouseX-bounds.x, item.mouseY-bounds.y) && !((item is Sprite) && !Sprite(item).mouseEnabled)) {				found = item;			}			return found;		}		/** *  Is the touch in bounds of a particular component? */		protected static function inBounds(item:DisplayObject, x:Number, y:Number):Boolean {			return x > item.x-MARGIN && y > item.y-MARGIN && x < item.x + item.width + MARGIN && y < item.y + item.height + MARGIN;		}		/** *  Is the touch in bounds of a particular component? */		protected static function inBoundsChild(item:DisplayObject, x:Number, y:Number):Boolean {			return x > -MARGIN && y > -MARGIN && x < item.width + MARGIN && y < item.height + MARGIN;		}		/** *  Clear scrolling form */		public function clear():void {				IContainerUI(_slider).clear();		}		/** *  Search for component that matches id */		public function findViewById(id:String, row:int=-1, group:int = -1):DisplayObject {			return IContainerUI(_slider).findViewById(id, row, group);		}						protected function get outsideSlideRange():Boolean {			return _sliderPosition >= 0 || _sliderPosition <= -_maximumSlide;		}				public function set sliderY(value:Number):void {		//	if (Math.abs(value - _sliderPosition) < MAXIMUM_DY) {				_sliderPosition = value;				if (_slider.visible) {					_slider.y = _sliderPosition;				}				sliderMoved();		//	}		}						public function get sliderY():Number {			return _sliderPosition;		}						public function set sliderVisible(value:Boolean):void {			if (value) {				addListeners();				hideScrollBar();			}			else {				removeListeners();			}			_slider.y = _sliderPosition;			_slider.visible = value;			_moveTimer.stop();			_touchTimer.stop();					}						public function get sliderVisible():Boolean {			return _slider.visible;		}		/** *  Set vertical scroll position */		public function set scrollPositionY(value:Number):void {			_sliderPosition = _slider.y = -value;			if (value > _maximumSlide) {				_sliderPosition = _slider.y = -_maximumSlide;			}			sliderMoved();		}						protected function sliderMoved():void {		//	if (_scrollBarLayer) {		//		_scrollBarLayer.graphics.clear();		//		_scrollBarVisible = false;		//	}		}						public function get scrollPositionY():Number {			return -sliderY;		}		/** *  Set array of objects data */		public function set data(values:Object):void {			if (_slider is UIForm) {				UIForm(_slider).data = values;				if (_autoLayout)					UIForm(_slider).doLayout();				adjustMaximumSlide();			}		}		/** *  Model */		public function get model():Model {			return (_slider is UIForm) ? UIForm(_slider).model : null;		}						override public function destructor():void {			super.destructor();			removeListeners();			_slider.removeEventListener(UIImageLoader.LOADED, doLayoutHandler);			_touchTimer.stop();			_moveTimer.stop();			_dragTimer.stop();			_clickTimer.stop();			UI.clear(_slider);		}	}}